apiVersion: networking.istio.io/v1alpha3
kind: EnvoyFilter
metadata:
  name: kubeflow-userid
  namespace: istio-system
spec:
  workloadSelector:
    labels:
      istio: ingressgateway
  configPatches:
  - applyTo: HTTP_FILTER
    match:
      context: GATEWAY
      listener:
        filterChain:
          filter:
            name: envoy.filters.network.http_connection_manager
            subFilter:
              name: envoy.filters.http.router
    patch:
      operation: INSERT_BEFORE
      value:
        name: envoy.filters.http.lua
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
          inline_code: |
            -- Json Parsing based on https://gist.github.com/tylerneylon/59f4bcf316be525b30ab
            -- See modified script on https://gist.github.com/inaiat/02bf5d11732d8e4d7b7546399a3a49af
            local alpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'

            local function toBinaryString(int)
                if int > 64 then error("Bad number " .. int .. " to convert to binary") end
                local remaining = tonumber(int)
                local bits = ''
                for i = 5, 0, -1 do
                    local pow = 2 ^ i
                    if remaining >= pow then
                        bits = bits .. '1'
                        remaining = remaining - pow
                    else
                        bits = bits .. '0'
                    end
                end
                return bits
            end
            local function fromBinaryString(bits) return tonumber(bits, 2) end
            local function decodeBase64(encoded)
                local bitstr = ''
                local decoded = ''
                for i = 1, string.len(encoded) do
                    local offset, _ = string.find(alpha, string.sub(encoded, i, i))
                    if offset == nil then
                        error("Bad base64 character " .. string.sub(encoded, i, i))
                    end
                    bitstr = bitstr .. toBinaryString(offset - 1)
                end
                for i = 1, string.len(bitstr), 8 do
                    decoded = decoded ..
                                  string.char(fromBinaryString(string.sub(bitstr, i, i + 7)))
                end
                return decoded
            end


            local json = {}

            local function skip_delim(str, pos, delim, err_if_missing)
                pos = pos + #str:match('^%s*', pos)
                if str:sub(pos, pos) ~= delim then
                    if err_if_missing then
                        error('Expected ' .. delim .. ' near position ' .. pos)
                    end
                    return pos, false
                end
                return pos + 1, true
            end

            local function parse_str_val(str, pos, val)
                val = val or ''
                local early_end_error = 'End of input found while parsing string.'
                if pos > #str then error(early_end_error) end
                local c = str:sub(pos, pos)
                if c == '"' then return val, pos + 1 end
                if c ~= '\\' then return parse_str_val(str, pos + 1, val .. c) end
                -- We must have a \ character.
                local esc_map = {b = '\b', f = '\f', n = '\n', r = '\r', t = '\t'}
                local nextc = str:sub(pos + 1, pos + 1)
                if not nextc then error(early_end_error) end
                return parse_str_val(str, pos + 2, val .. (esc_map[nextc] or nextc))
            end

            local function parse_num_val(str, pos)
                local num_str = str:match('^-?%d+%.?%d*[eE]?[+-]?%d*', pos)
                local val = tonumber(num_str)
                if not val then error('Error parsing number at position ' .. pos .. '.') end
                return val, pos + #num_str
            end

            json.null = {}
            function json.parse(str, pos, end_delim)
                pos = pos or 1
                if pos > #str then error('Reached unexpected end of input.') end
                local pos = pos + #str:match('^%s*', pos) -- Skip whitespace.
                local first = str:sub(pos, pos)
                if first == '{' then -- Parse an object.
                    local obj, key, delim_found = {}, true, true
                    pos = pos + 1
                    while true do
                        key, pos = json.parse(str, pos, '}')
                        if key == nil then return obj, pos end
                        if not delim_found then
                            error('Comma missing between object items.')
                        end
                        pos = skip_delim(str, pos, ':', true) -- true -> error if missing.
                        obj[key], pos = json.parse(str, pos)
                        pos, delim_found = skip_delim(str, pos, ',')
                    end
                elseif first == '[' then -- Parse an array.
                    local arr, val, delim_found = {}, true, true
                    pos = pos + 1
                    while true do
                        val, pos = json.parse(str, pos, ']')
                        if val == nil then return arr, pos end
                        if not delim_found then
                            error('Comma missing between array items.')
                        end
                        arr[#arr + 1] = val
                        pos, delim_found = skip_delim(str, pos, ',')
                    end
                elseif first == '"' then -- Parse a string.
                    return parse_str_val(str, pos + 1)
                elseif first == '-' or first:match('%d') then -- Parse a number.
                    return parse_num_val(str, pos)
                elseif first == end_delim then -- End of an object or array.
                    return nil, pos + 1
                else -- Parse true, false, or null.
                    local literals = {
                        ['true'] = true,
                        ['false'] = false,
                        ['null'] = json.null
                    }
                    for lit_str, lit_val in pairs(literals) do
                        local lit_end = pos + #lit_str - 1
                        if str:sub(pos, lit_end) == lit_str then
                            return lit_val, lit_end + 1
                        end
                    end
                    local pos_info_str = 'position ' .. pos .. ': ' ..
                                            str:sub(pos, pos + 10)
                    error('Invalid json syntax starting at ' .. pos_info_str)
                end
            end

            function print_table(data)
              for key, value in pairs(data) do
                  print(key)
                  print(value)
              end
            end

            function envoy_on_request(request_handle)
              print("hello from filter")
              local jwt_head = request_handle:headers():get("x-amzn-oidc-data")
              local kf_email = request_handle:headers():get("kubeflow-userid")
              local request_headers = request_handle:headers()
              
              if kf_email ~= null then
                print("email-id header present")
                request_handle:headers():add("kubeflow-userid", kf_email)
              end

              if jwt_head==null then
                request_handle:logWarn("there is is no jwt token")
                if kf_email==null then
                  request_handle:logWarn("there is is no kf user-id")
                end
              else
                print("x-amzn-oidc-data present")
                --- print(jwt_head)
                jwt_table={}
                local jwt_keys={"header", "payload", "signature"}
                local i=1
                for token in jwt_head:gmatch("([^.]+)") do
                  jwt_table[jwt_keys[i]]=token
                  i=i+1
                end
                --- print("payload")
                --- print(jwt_table["payload"]:gsub('%=', ''))
                local trimmed_claims=jwt_table["payload"]:gsub('%=', '')
                local decoded_payload=decodeBase64(trimmed_claims)
                --- print(decoded_payload)
                local claims = json.parse(decoded_payload)
                if claims==nil then
                  request_handle:logWarn("some problems to get jwt attributes"..jwt_head)
                else
                  local email = claims["email"]
                  --- print(email)
                  request_handle:headers():add("kubeflow-userid", email)
                  request_headers = request_handle:headers()
                  kf_email = request_handle:headers():get("kubeflow-userid")
                  if kf_email ~= null then
                    print("email-id header added "..kf_email)
                  end
                end
              end
            end
